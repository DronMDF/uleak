#summary Классификация проблем с памятью

== Утечка памяти ==

Выделяемая память не освобождается, или освобождается не полностью.

Приложение использует все больше и больше памяти.
Но это понятие весьма относительно, если утечка мала и происходит не слишком
часто, то этого можно даже и не заметить. Особенно по статистике памяти, которая
меряется мегабайтами.

Для обнаружения подсчитывается количество одновременно выделенных блоков в
каждой точке выделения (точке вызова менеджера памяти).
Если количество блоков в точке постоянно растет - вероятно, имеет место утечка.

Если необходимо проверить какой-нибудь редко вызываемый в реальной жизни модуль
- лучше всего отделить его от кода приложения (возможно в юниттесте) и запустить
в цикле достаточное количество раз, чтобы утечка дала о себе знать.

== Переполнение блока ==

Приложение использует больше памяти, чем было запрошено. 

Buffer Overflow в динамической памяти.

Часто это приводит к падению приложения в следствии нарушения работы менеджера
памяти.
Но если переполнение памяти не слишком велико, например типичный случай с
си-строками - malloc(strlen(s)), то последствия могут быть не так разрушительны,
и все зависит от длины строки.

Для обнаружения за пределами запрошенной памяти создается специальная буфферная
зона, содержимое которой контролируется в процессе работы и после освобождения
блока.
В случае малейшего нарушения - приложение останавливается.

== Использование блока после освобождения ==

Приложение использует блок после освобождения.

Может привести к труднообъяснимым падениям приложения.
Поскольку освобожденная память может быть уже выделена для других целей и
заполнена другими значениями.
Часто возникает в многопоточных приложениях в следствии плохой синхронизации.

Использование блока может происходить как на чтение, так и на запись.
В первом случае есть вероятность прочитать некорректные данные (блок может быть
уже использован для других целей), что вызовет нарушение работы этого кода.
Во втором случае есть вероятность нарушить работу другого кода.

Обнаружение этого нарушения предстваляет из себя большую проблему.
В первую очередь необходимо производить заполнение освобождаемых блоков
специальным значением.
Если приложение начнет читать эту память - оно заведомо получит не то, что
нужно.
Чтобы отследить модицикацию памяти - содержимое свободных блоков необходимо
переодически контролировать (так что заполнение случайными данными - плохая идея).
В случае нарушений свободных блоков работа приложения немедленно останавливается.

Для большей информативности в служебной области блока может быть сохранена
информация о том, откуда этот блок выделяли, и откуда освободили.
Если и это не помогает можно созранять не один а несколько адресов из стека
вызовов.

== Двойное освобождение блока ==

Если блок с момента освобождения не изменился, то менеджер памяти скорее всего отследит эту ситуацию, но если менеджер памяти уже успел подсуетиться и отдать этот блок кому-то еще, последствия просто непредсказуемы. Он скорее всего освободит его. При этом выделивший ее код останется в неведении.

== Использование неинициализированной памяти после выделения ==

== Блок нулевой длины == 

В стандарте си по этому поводу написано, что поведение может определяться реализацией. If the size of the space requested is zero, the behavior is implementation-deﬁned: either a null pointer is returned, or the behavior is as if the size were some nonzero value, except that the returned pointer shall not be used to access an object.

Однако далеко не всем приложения может понравиться NULL в ответ на malloc. Хотя помоему это наиболее правильный вариант. Допустимым также можно считать указатель куда нибудь на ридонли память, чтобы приложение не пыталось туда что-нибудь писать. Кстати вот не знаю как должен вести себя в этом случае operator new?

== Освобождение нулевого указателя == 

Освобождение нулевого указателя. Это даже и не проблема а вполне допустимая операция. Но если приложение дергает ее слишком часто - повод задуматься.

== Замусоривание памяти == 

Спонтанное замусоривание памяти. Скорее всего возникает в следствии других ошибок. Прежде чем бороться с духами в приложении, лучше разобраться с явными вещами. :)