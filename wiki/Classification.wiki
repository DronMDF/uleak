#summary Классификация проблем с памятью

== Утечка памяти ==

Выделяемая память не освобождается, или освобождается не полностью.
{{{
malloc(100);
exit(0);
}}}
Приложение использует все больше и больше памяти.
Но это понятие весьма относительно, если утечка мала и происходит не слишком
часто, то этого можно даже и не заметить. Особенно по статистике памяти, которая
меряется мегабайтами.

Для обнаружения подсчитывается количество одновременно выделенных блоков в
каждой точке выделения (точке вызова менеджера памяти).
Если количество блоков в точке постоянно растет - вероятно, имеет место утечка.

Если необходимо проверить какой-нибудь редко вызываемый в реальной жизни модуль
- лучше всего отделить его от кода приложения (возможно в юниттесте) и запустить
в цикле достаточное количество раз, чтобы утечка дала о себе знать.

== Переполнение блока ==

Приложение использует больше памяти, чем было запрошено.
Buffer Overflow в динамической памяти.
{{{
ptr = malloc(strlen(s));
strcpy(ptr, s);
}}}
Часто это приводит к падению приложения в следствии нарушения работы менеджера
памяти.
Но если переполнение памяти не слишком велико, например типичный случай с
си-строками - malloc(strlen(s)), то последствия могут быть не так разрушительны,
и все зависит от длины строки.

Для обнаружения за пределами запрошенной памяти создается специальная буфферная
зона, содержимое которой контролируется в процессе работы и после освобождения
блока.
В случае малейшего нарушения - приложение останавливается.

== Использование блока после освобождения ==

Приложение использует блок после освобождения.
{{{
free(ptr);
memset(ptr, 0, size);
}}}
Может привести к труднообъяснимым падениям приложения.
Поскольку освобожденная память может быть уже выделена для других целей и
заполнена другими значениями.
Часто возникает в многопоточных приложениях в следствии плохой синхронизации.

Использование блока может происходить как на чтение, так и на запись.
В первом случае есть вероятность прочитать некорректные данные (блок может быть
уже использован для других целей), что вызовет нарушение работы этого кода.
Во втором случае есть вероятность нарушить работу другого кода.

Обнаружение этого нарушения предстваляет из себя большую проблему.
В первую очередь необходимо производить заполнение освобождаемых блоков
специальным значением.
Если приложение начнет читать эту память - оно заведомо получит не то, что
нужно.
Чтобы отследить модицикацию памяти - содержимое свободных блоков необходимо
переодически контролировать (так что заполнение случайными данными - плохая идея).
В случае нарушений свободных блоков работа приложения немедленно останавливается.

Для большей информативности в служебной области блока может быть сохранена
информация о том, откуда этот блок выделяли, и откуда освободили.
Если и это не помогает можно созранять не один а несколько адресов из стека
вызовов.

== Двойное освобождение блока ==

Приложение пытается дважды освободить один и тот же указатель.
{{{
free(ptr);
free(ptr);
}}}
Если блок с момента освобождения не изменился, то менеджер памяти скорее всего
отследит эту ситуацию.
Но если менеджер памяти уже успел отдать этот блок кому-то еще, последствия
просто непредсказуемы.
Он скорее всего освободит его.
При этом выделивший ее другой код останется в неведении.

Диагностика этой ситуации возможна только на пустых блоках.
Менеджер памяти строится так, чтобы избежать изменения блоков.
Он может быть даже построен по принципу выделения того блока, который
освободился раньше всех.
Как это, LRU чтоль?
Тем самым сохраняя освобожденные блоки в неприкосновенности для обнаружения
данной проблемы.

== Использование неинициализированной памяти после выделения ==

Приложение не инициализирует память.
{{{
str = malloc(100);
printf("%s\n", str);
}}}
Собственно менеджер памяти практически ничего не может с этим поделать.
Разве что заполнить память чем нибудь.
Но заполнять память нулями - это слишком непоказательно.
Наоборот, память надо заполнять всяким мусором, чтобы приложение по возможности
падало, предоставляя нам возможность узнать об этом.

== Блок нулевой длины == 

Выделение пустого блока.
{{{
malloc(0);
}}}
В стандарте си по этому поводу написано:

If the size of the space requested is zero, the behavior is
implementation-deﬁned: either a null pointer is returned, or the behavior is as
if the size were some nonzero value, except that the returned pointer shall
not be used to access an object.

Однако, далеко не всем приложения может понравиться NULL в ответ на malloc.
Хотя, помоему, это наиболее правильный вариант.
Допустимым также можно считать указатель куда нибудь на ридонли память, чтобы
приложение не пыталось туда что-нибудь писать.

Кстати вот не знаю как должен вести себя в этом случае operator new?

Выделения подобного рода скорее всего ошибочны, но могут встречаться в
библиотеках.
Кроме того они могут вызывать утечки, если менеджер памяти пытается их выделять.

Попытку записи в такие блоки можно рассматривать как переполнение блока, и
отлавливать соответственно.
Для этого необходимо выделять эти блоки на общих основаниях.

== Освобождение нулевого указателя == 

Приложение пытается освобождать блок с нулевым указателем.
{{{
free(0);
}}}
Это вполне допустимая операция.
Но слишком частое ее использование (особенно при условии что malloc(0) никогда
не возвращает 0), говорит об архитектурных проблемах.

== Замусоривание памяти == 

Может быть вообще не связано с динамической памятью.
Например, модификация данных по неинициализированному указателю.

Лучшим средством от этого является инициализация переменных.

Контроль содержимого блоков после освобождения может помочь решить данную
проблему.
Но это если очень повезет, и кривой указатель приведет в менеджер памяти.

== Непарность операций по работе с памятью ==

Существует три пары операций по работе с динамической памятью:
{{{
*alloc/free
new/delete
new[]/delete[]
}}}
Любое нарушение должно являться фатальным. Вполне типичным является нарушение
типа new[]/delete.
Отследить его достаточно легко, достаточно фиксировать тип выделения в заголовке
блока и сравнивать его при освобождении.
